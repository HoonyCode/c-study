## 목표
동적할당에 대해서 알아보자

## 학습할 것
- 동적할당이란 무엇인가?
- 동적할당의 장점
- 동적할당의 단점
- 동적할당 정의하는 법
- 1차원 배열의 할당
- 2차원 배열의 할당
- malloc, realloc, calloc의 비교

# 숙제
- https://www.acmicpc.net/step/1 있는 문제 다 풀어오기

## 스터디 일시
2021년 10월 10일 오후 1시

## 목차
- [숙제](#숙제)
  - [스터디 일시](#스터디-일시)
  - [목차](#목차)
    - [동적할당이란 무엇인가?](#동적할당이란-무엇인가)
    - [동적할당의 장점](#동적할당의-장점)
    - [동적할당의 단점](#동적할당의-단점)
    - [동적할당 정의](#동적할당-정의)
    - [1차원 배열의 할당](#1차원-배열의-할당)
    - [2차원 배열의 할당](#2차원-배열의-할당)
    - [malloc, realloc, calloc의 비교](#malloc-realloc-calloc의-비교)
    - [추가](#추가)
---


### 동적할당이란 무엇인가?

내가 C언어에서 배열을 정할 떄는 그 크기를 언제나 컴파일 시간에 확정되게 정수를 넣어줬어야 한다.  
하지만, 우리가 어떤 사람들의 수를 모르고 연속적으로 데이터를 받아 배열에 넣게 되면 내가 확정적으로 넣은 정수의 크기가 작거나 너무 크게 될 문제가 생긴다.

이러한 문제를 해결하기 위해서 우리는 `동적 메모리 할당`이라는 방법이 있다.

즉, 동적할당을 한마디로 말하면
```
가변적으로 배열의 크기를 늘렸다가 줄였다가 할 수 있는 방법이다.
```
---

### 동적할당의 장점
상황에 따라 원하는 크기만큼의 메모리가 할당되게 할 수 있으므로 경제적이며, 이미 할당된 메모리라도 언제든지 크기를 수정할 수 있다.

---

### 동적할당의 단점
동적할당 배열을 더 이상 사용하지 않을 때 명시적으로 메모리를 해제해 주어야 한다.
```
즉, 귀찬다.
```
---
### 동적할당 정의

동적할당을 하기 위해서는 malloc 함수를 사용해서 메모리 공간을 확보해야 한다.

`malloc`은 `memory allocation`의 줄임말이다.
`malloc` 함수는 `stdlib.h` 헤더 파일에 선언되어 있다.

동적할당 하는 방법
```C
포인터 = malloc(크기);
    void *malloc(size_t_Size);
    //성공하면 메모리 주소를 반환, 실패하면 NULL을 반환
    
    free(포인터); // 동적으로 할당한 메모리 해제
```

예시 : 배열의 크기를 받아드리고 동적할당 하는 방법
```C
#include <stdlib.h>

int main(){
    int num;
    scanf("%d", &num);
    int* arr;
    arr = (int*)malloc(sizeof(int)*num);
    // malloc의 반환 결과는 주소를 반환한다.
    free(arr) // 동적으로 할당한 메모리 해제
    return 0;
}
```

주의 할 점
메모리 해제는 선택이 아닌 필수이다.  
면 결국에는 시스템의 메모리가 부족해지게 되면 운영체제가 프로그램을 강제로 종료시키거나 메모리 할당에 실패하게 된다.  

특히 메모리를 해제하지 않아 메모리 사용량이 계속 증가하는 현상을 `메모리 누수`라 부른다.

---
### 1차원 배열의 할당
일차원 배열을 할당하는 방법은 위에서 한 것처럼 어렵지 않다.

예시

```C
포인트타입 변수명 = (포인트타입)malloc(sizeof(변수타입)* 배열의개수);

free(변수명);
```
---
### 2차원 배열의 할당

이차원 배열을 할당하는 방법은 일차원 배열을 두번 할당한다고 생각하면 된다.

예시 : arr[i][j] 만들기
```C

자료 타입** 변수명 = (자료타입**)malloc(sizeof(자료타입*) * i의 크기);

for(int k = 0 ; k < i ; k++){
    arr[k] = (자료타입 *)malloc(sizeof(자료타입) * j);
}

//free 부분
for(int k = 0 ; k < i ; k++){
    free(arr[k]);
}

free(arr);

```
---
### malloc, realloc, calloc의 비교

- malloc
  - memory allocation
  - 원형 함수 : void *malloc(unsigned int);
  - 할당된 공간의 값들을 바꾸지 않음
  - 리턴값은 할당된 주소

- realloc
  - clear allocation
  - 원형 함수 : void *calloc(unsigned int, unsigned int);
  - 첫번째 인자는 배열요소의 갯수, 두번째 인자는 할당받을 공간의 크기
  - 할당된 공간 값들을 0으로 초기화 한다.
  - 리턴값은 할당된 주소

- calloc
  - resize allocation
  - 원형 함수 : void *realloc(void* size_t size);
  - 동적 메모리의 재할당
  - 리턴값은 재할당된 주소(재변경시 메모리(힙) 공간의 문제로 다른 위치로 변경될 수 있다.)

---
### 추가

메모리의 구조 
- 코드영역  
- 데이터 영역  
- 힙 영역  
- 스택 영역 

메모리 영역별로 저장되는 데이터 유형
- 코드 영역 : 실행될 코드가 저장되는 메모리 공간

- 데이터 영역 : 전역변수와 static 변수가 할당된다.
    - 데이터 생성시점 : 프로그램 실행 시 
    - 데이터 소멸시점 : 프로그램 종료 시  


- 스택영역 : 지역변수와 매개변수가 할당된다.
  - 데이터 생성시점 : 함수 진입 시
  - 데이터 소멸시점 : 함수 return 시

- 힙 영역 : 프로그래머가 원하는 변수를 할당한다.
  - 데이터 생성시점 : 프로그래머가 원할 때
  - 데이터 소멸시점 : 프로그래머가 원할 때

동적할당은 어디에 메모리가 할당될까?  
```
동적할당은 프로그래머 마음대로 malloc 해서 할당하고 free를 통해 메모리를 해제(소멸?) 시킬 수 있으므로 힙 영역에 할당된다.
```
---
